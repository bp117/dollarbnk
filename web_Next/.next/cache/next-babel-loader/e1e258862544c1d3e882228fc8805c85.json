{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { getMyTransfers, createTransfer } from 'api/transfers';\nimport * as actionTypes from './actionTypes';\nexport const fetchTransfers = () => async dispatch => {\n  try {\n    // Set status to false on every start, so it can be reusable\n    dispatch(fetchTransfersStatus(false));\n    const data = await getMyTransfers();\n\n    if (!data) {\n      dispatch(fetchTransfersStatus(false));\n      return;\n    }\n\n    dispatch({\n      type: actionTypes.FETCH_TRANSFERS,\n      data\n    });\n  } catch (err) {\n    dispatch(fetchTransfersStatus(false));\n  }\n};\nexport const fetchTransfersStatus = status => ({\n  type: actionTypes.FETCH_TRANSFERS_STATUS,\n  status\n});\nexport const addTransfer = data => async dispatch => {\n  try {\n    const transData = _objectSpread({}, data, {\n      amount: parseFloat(data.amount).toFixed(2),\n      date: new Date(),\n      payeeAccNumber: parseInt(data.payeeAccNumber, 10),\n      payeeSortcode: parseInt(data.payeeSortcode, 10),\n      status: 'Done',\n      type: 'Transfer'\n    });\n\n    const transfer = await createTransfer(transData);\n\n    if (!transfer) {\n      dispatch(fetchTransfersStatus(false));\n      return;\n    }\n\n    dispatch({\n      type: actionTypes.ADD_TRANSFER,\n      data: transData\n    });\n  } catch (err) {\n    dispatch(fetchTransfersStatus(false));\n  }\n};","map":{"version":3,"sources":["/Users/binduraj/Documents/GitHub/dollarbank/web_Next/helper/actions/transfers.js"],"names":["getMyTransfers","createTransfer","actionTypes","fetchTransfers","dispatch","fetchTransfersStatus","data","type","FETCH_TRANSFERS","err","status","FETCH_TRANSFERS_STATUS","addTransfer","transData","amount","parseFloat","toFixed","date","Date","payeeAccNumber","parseInt","payeeSortcode","transfer","ADD_TRANSFER"],"mappings":";;;;;;AAAA,SAASA,cAAT,EAAyBC,cAAzB,QAA+C,eAA/C;AACA,OAAO,KAAKC,WAAZ,MAA6B,eAA7B;AAEA,OAAO,MAAMC,cAAc,GAAG,MAAM,MAAMC,QAAN,IAAkB;AACnD,MAAI;AACD;AACAA,IAAAA,QAAQ,CAACC,oBAAoB,CAAC,KAAD,CAArB,CAAR;AAEA,UAAMC,IAAI,GAAG,MAAMN,cAAc,EAAjC;;AAEA,QAAI,CAACM,IAAL,EAAW;AACRF,MAAAA,QAAQ,CAACC,oBAAoB,CAAC,KAAD,CAArB,CAAR;AACA;AACF;;AAEDD,IAAAA,QAAQ,CAAC;AAAEG,MAAAA,IAAI,EAAEL,WAAW,CAACM,eAApB;AAAqCF,MAAAA;AAArC,KAAD,CAAR;AACF,GAZD,CAYE,OAAOG,GAAP,EAAY;AACXL,IAAAA,QAAQ,CAACC,oBAAoB,CAAC,KAAD,CAArB,CAAR;AACF;AACH,CAhBM;AAkBP,OAAO,MAAMA,oBAAoB,GAAGK,MAAM,KAAK;AAC5CH,EAAAA,IAAI,EAAEL,WAAW,CAACS,sBAD0B;AAE5CD,EAAAA;AAF4C,CAAL,CAAnC;AAKP,OAAO,MAAME,WAAW,GAAGN,IAAI,IAAI,MAAMF,QAAN,IAAkB;AAClD,MAAI;AACD,UAAMS,SAAS,qBACTP,IADS;AAEZQ,MAAAA,MAAM,EAAEC,UAAU,CAACT,IAAI,CAACQ,MAAN,CAAV,CAAwBE,OAAxB,CAAgC,CAAhC,CAFI;AAGZC,MAAAA,IAAI,EAAE,IAAIC,IAAJ,EAHM;AAIZC,MAAAA,cAAc,EAAEC,QAAQ,CAACd,IAAI,CAACa,cAAN,EAAsB,EAAtB,CAJZ;AAKZE,MAAAA,aAAa,EAAED,QAAQ,CAACd,IAAI,CAACe,aAAN,EAAqB,EAArB,CALX;AAMZX,MAAAA,MAAM,EAAE,MANI;AAOZH,MAAAA,IAAI,EAAE;AAPM,MAAf;;AAUA,UAAMe,QAAQ,GAAG,MAAMrB,cAAc,CAACY,SAAD,CAArC;;AAEA,QAAI,CAACS,QAAL,EAAe;AACZlB,MAAAA,QAAQ,CAACC,oBAAoB,CAAC,KAAD,CAArB,CAAR;AACA;AACF;;AAEDD,IAAAA,QAAQ,CAAC;AACNG,MAAAA,IAAI,EAAEL,WAAW,CAACqB,YADZ;AAENjB,MAAAA,IAAI,EAAEO;AAFA,KAAD,CAAR;AAIF,GAtBD,CAsBE,OAAOJ,GAAP,EAAY;AACXL,IAAAA,QAAQ,CAACC,oBAAoB,CAAC,KAAD,CAArB,CAAR;AACF;AACH,CA1BM","sourcesContent":["import { getMyTransfers, createTransfer } from 'api/transfers';\nimport * as actionTypes from './actionTypes';\n\nexport const fetchTransfers = () => async dispatch => {\n   try {\n      // Set status to false on every start, so it can be reusable\n      dispatch(fetchTransfersStatus(false));\n\n      const data = await getMyTransfers();\n\n      if (!data) {\n         dispatch(fetchTransfersStatus(false));\n         return;\n      }\n\n      dispatch({ type: actionTypes.FETCH_TRANSFERS, data });\n   } catch (err) {\n      dispatch(fetchTransfersStatus(false));\n   }\n};\n\nexport const fetchTransfersStatus = status => ({\n   type: actionTypes.FETCH_TRANSFERS_STATUS,\n   status\n});\n\nexport const addTransfer = data => async dispatch => {\n   try {\n      const transData = {\n         ...data,\n         amount: parseFloat(data.amount).toFixed(2),\n         date: new Date(),\n         payeeAccNumber: parseInt(data.payeeAccNumber, 10),\n         payeeSortcode: parseInt(data.payeeSortcode, 10),\n         status: 'Done',\n         type: 'Transfer'\n      };\n\n      const transfer = await createTransfer(transData);\n\n      if (!transfer) {\n         dispatch(fetchTransfersStatus(false));\n         return;\n      }\n\n      dispatch({\n         type: actionTypes.ADD_TRANSFER,\n         data: transData\n      });\n   } catch (err) {\n      dispatch(fetchTransfersStatus(false));\n   }\n};\n"]},"metadata":{},"sourceType":"module"}