{"ast":null,"code":"import format from 'date-fns/format';\nimport jwtDecode from 'jwt-decode';\nimport nextCookie from 'next-cookies';\nimport cookie from 'js-cookie';\nimport Router from 'next/router'; // Add padding from the start of the current string/number\n\nexport const myPadStart = (el, targetLength, padString) => {\n  return el.toString().padStart(targetLength, padString);\n}; // Insert something after every n characters in the string\n\nexport const chunker = (el, step, string) => {\n  const regExp = new RegExp(`.{${step}}`, 'g');\n  return el.toString().match(regExp).join(string);\n}; // Format date\n\nexport const formatDate = (date, dateFormat) => format(new Date(date), dateFormat); // Token checker\n\nexport const getAuthToken = () => {\n  return cookie.get('token');\n};\nexport const setAuthToken = token => {\n  cookie.set('token', token);\n};\nexport const removeAuthToken = () => {\n  cookie.remove('token');\n};\nexport const isValidToken = () => {\n  return new Promise((resolve, reject) => {\n    const token = checkValidToken();\n\n    if (token) {\n      resolve(token);\n    } else {\n      reject();\n    }\n  });\n};\nexport const checkValidToken = () => {\n  const currentTime = Date.now().valueOf() / 1000;\n  const token = getAuthToken();\n\n  if (!token) {\n    return;\n  }\n\n  const decodedToken = jwtDecode(token); // If token expired - remove it\n\n  if (decodedToken.exp < currentTime) {\n    removeAuthToken();\n    return;\n  }\n\n  return token;\n};\nexport const auth = ctx => {\n  const {\n    token\n  } = nextCookie(ctx),\n        {\n    pathname\n  } = ctx;\n\n  if (pathname === '/login') {\n    if (!token) {\n      return false;\n    }\n\n    if (true) {\n      ctx.res.writeHead(302, {\n        Location: '/panel'\n      });\n      ctx.res.end();\n    } else {\n      Router.push('/panel');\n    }\n  } // If there's no token, it means the user is not logged in.\n\n\n  if (!token) {\n    if (true) {\n      ctx.res.writeHead(302, {\n        Location: '/login'\n      });\n      ctx.res.end();\n    } else {\n      Router.push('/login');\n    }\n  }\n\n  return token;\n};","map":{"version":3,"sources":["/Users/binduraj/Documents/GitHub/dollarbank/web_Next/helper/tools/index.js"],"names":["format","jwtDecode","nextCookie","cookie","Router","myPadStart","el","targetLength","padString","toString","padStart","chunker","step","string","regExp","RegExp","match","join","formatDate","date","dateFormat","Date","getAuthToken","get","setAuthToken","token","set","removeAuthToken","remove","isValidToken","Promise","resolve","reject","checkValidToken","currentTime","now","valueOf","decodedToken","exp","auth","ctx","pathname","res","writeHead","Location","end","push"],"mappings":"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","sourcesContent":["import format from 'date-fns/format';\nimport jwtDecode from 'jwt-decode';\nimport nextCookie from 'next-cookies'\nimport cookie from 'js-cookie'\nimport Router from 'next/router'\n\n// Add padding from the start of the current string/number\nexport const myPadStart = (el, targetLength, padString) => {\n   return el.toString().padStart(targetLength, padString);\n};\n\n// Insert something after every n characters in the string\nexport const chunker = (el, step, string) => {\n   const regExp = new RegExp(`.{${step}}`, 'g');\n   return el\n      .toString()\n      .match(regExp)\n      .join(string);\n};\n\n// Format date\nexport const formatDate = (date, dateFormat) => format(new Date(date), dateFormat);\n\n// Token checker\nexport const getAuthToken = () => {\n   return cookie.get('token');\n};\n\nexport const setAuthToken = token => {\n   cookie.set('token', token)\n};\n\nexport const removeAuthToken = () => {\n   cookie.remove('token')\n};\n\nexport const isValidToken = () => {\n\n   return new Promise((resolve, reject) => {\n      const token = checkValidToken();\n\n      if (token) {\n          resolve(token)\n      } else {\n          reject()\n      }\n   });\n};\n\nexport const checkValidToken = () => {\n    const currentTime = Date.now().valueOf() / 1000;\n    const token = getAuthToken();\n\n    if (!token) {\n        return;\n    }\n\n    const decodedToken = jwtDecode(token);\n\n    // If token expired - remove it\n    if (decodedToken.exp < currentTime) {\n        removeAuthToken();\n        return;\n    }\n\n    return token;\n}\n\nexport const auth = ctx => {\n    const { token } = nextCookie(ctx),\n        { pathname } = ctx\n\n    if (pathname === '/login') {\n        if (!token)  {\n            return false\n        }\n\n        if (typeof window === 'undefined') {\n            ctx.res.writeHead(302, { Location: '/panel' })\n            ctx.res.end()\n        } else {\n            Router.push('/panel')\n        }\n    }\n\n\n    // If there's no token, it means the user is not logged in.\n    if (!token)  {\n        if (typeof window === 'undefined') {\n            ctx.res.writeHead(302, { Location: '/login' })\n            ctx.res.end()\n        } else {\n            Router.push('/login')\n        }\n    }\n\n    return token\n}"]},"metadata":{},"sourceType":"module"}